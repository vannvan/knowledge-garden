### 相关文章

[详解http协议](https://www.cnblogs.com/AhuntSun-blog/p/12529920.html)

### 一次完整的HTTP事务流程

（1）域名解析

（2）发起TCP的三次握手

（3）建立TCP连接后发起http请求

（4）服务器响应http请求，浏览器得到HTML代码

（5）浏览器解析HTML代码，并请求HTML代码中的资源

（6）浏览器对页面进行渲染呈现给用户

（7）连接结束 （四次挥手）

### **Tcp三次握手？四次挥手？**

三次握手的必要性：为了保证服务器能接收到客户端的信息并做出正确的应答而进行前两次（第一次和第二次）握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次（第二次和第三次）握手。

![](https://img-blog.csdn.net/20180306090528688)

上图部分标志说明：

（1）ACK：TCP规定，只有当ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1

（2）SYN（SYNchronization）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这个是一个连接请求报文。对方若同意建立连接，则响应报文中SYN=1，ACK=1。因此，SYN置1表示这是一个连接请求或连接接受报文。

（3）FIN（finish）：终结的意思，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并请求释放连接。

三次握手说明：

（1）第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置1，序列号seq（sequence number）为x；然后，客户端进入SYN_SEND状态，等待服务器的确认。

（2）第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，ACK位置1，确认号ack（acknowledgement number）为x+1；同时，自己还要发送SYN请求信息，将SYN位置1，序列号seq为y；服务器将上述SYN+ACK报文段一并发送给客户端，此时服务器进入SYN_RECV状态。

（3）第三次握手：客户端收到服务器的SYN+ACK报文段。然后将确认号ack设置为y+1，向服务器发送ACK报文段。这个报文段发送完毕后，客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手，之后可以开始传数据。

四次挥手：当客户端和服务器通过三次握手建立了TCP连接之后，当数据传输完毕，就要断开TCP连接，这个过程称为四次挥手。四次挥手说明：

- 第一次挥手(FIN=1，seq=x)
  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，`表示自己已经没有数据可以发送了，但是仍然可以接受数据。`
  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。
- 第二次挥手(ACK=1，ACKnum=x+1)
  服务器端确认客户端的 FIN 包，发送一个确认包，`表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。`
  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。
- 第三次挥手(FIN=1，seq=y)
  `服务器端准备好关闭连接时，向客户端发送结束连接请求`，FIN 置为1。
  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。
- 第四次挥手(ACK=1，ACKnum=y+1)
  `客户端接收到来自服务器端的关闭请求，发送一个确认包`，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。
  `服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。`
  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。


### **HTTP请求码及其作用？**

HTTP状态码：当用户访问一个网页时，浏览器会向网页所在的服务器出请求，当浏览器接收并显示网页前，此网页所在服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求，HTTP状态码用于描述服务器对请求的处理结果。

HTTP状态码分类：

（1）1**：信息，服务器收到请求，需要请求者继续执行操作

（2）2**：成功，操作被成功接收并处理

（3）3**：重定向，需要进一步的操作以完成请求

（4）4**：客户端错误，请求包含语法错误或者无法完成请求

（5）5**：服务器错误，服务器在处理请求的过程中发生了错误

常见的HTTP状态码：

- 200——OK，请求成功
- 301——Moved Permanently，资源（网页等）被永久转移到其他URL
- 302——Found，307——Temporary Redirect，临时重定向，请求的文档被临时移动到别处 
- 304——Not Modified，未修改，表示客户端缓存的版本是最近的 💛
- 401——Unauthorized，请求要求用户的身份认证
- 403——Forbidden，禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致
- 404——Not Found，请求的资源（网页等）不存在
- 500——Internal Server Error——内部服务器错误
- 502——Bad Gateway，充当网关或代理的服务器从远端服务器接收到了一个无效的请求
- 504——Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求

### **浏览器解析渲染过程？**

（1）浏览器解析HTML源码，然后创建一个DOM树。

在DOM树中，每一个HTML标签都有一个对应的节点（元素节点），并且每一个文本也都有一个对应的文本节点，DOM树的根节点就是documentElement，对应的是html标签

（2）浏览器解析CSS代码，然后创建一个CSSOM树。

解析CSS的时候会按照如下顺序来定义优先级（递增）：浏览器默认设置<用户设置<外联样式<内联样式<标签样式

（3）根据DOM树和CSSOM来构建一个渲染树（render tree）。

（4）当渲染树创建完成之后，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

### **为什么要先引入css文件，再引入js文件？**

（1）js代码的下载是阻塞下载，不可以和其他代码并行下载和解析；CSS的加载不会阻塞DOM树的解析（会阻塞其渲染，也会阻塞后面的js执行）

（2）页面加载时，是按照从上到下，从左到右的顺序加载的。如果将js放在前面，会立即执行，阻塞后续的资源下载和执行。如果外部脚本加载时间过长，会造成网页长时间失去响应，浏览器就会呈现“假死”状态（阻塞效应）

（2）页面需要等到head中的js和css加载完成之后才开始绘制，当js放在body最后时，不需要等待，可以避免资源阻塞，同时使静态页面迅速显示

（3）部分js的执行依赖于前面的样式。

（4）js一般是处理功能，所以不需要提前加载。先给用户观感，在给用户上手体验。

### http各版本区别

- `HTTP/0.9 `  1991

> 只支持`GET`命令，服务器只能回应`HTML`字符串，没有其他格式  

```js
<html>
  <body>Hello World</body>
</html>
```

> 服务器发送完毕就关闭`TCP`连接

- `HTTP/1.0`  1995

> 任何格式的内容都可以发送

> 增加了`POST`和`HEAD`命令

> HTTP请求和回应的格式也变了,除了通信部分之外，还必须包括头信息，用来描述元数据

> 新增状态码、支持多字符集、多部分发送、权限、缓存、内容编码

请求格式示例：

```js
GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

回应格式内容示例：

```js
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

**Content-Type**

- text/plain
- text/html
- text/css
- image/jpeg
- image/png
- image/svg+xml
- audio/mp4
- video/mp4
- application/javascript
- application/pdf
- application/zip
- application/atom+x

**Content-Encoding**

```http
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
```

**该版本缺点**

每个`TCP`连接只能发送一个请求，发送数据完毕，连接就关闭，极大的浪费了服务器资源，每次新建连接的成本都很高，为了解决这个问题，有些浏览器采用了非标准的`Connection`字段，这个字段表示要求服务器不要关闭资源，这样虽然一个可以复用的`TCP`连接了，但是由于像客户端与服务器时间不一致，会产生行为的不一致性，所以也并没有从根本上解决问题。

- `HTTP/1.1`  1997   到现在还是最流行的版本

**持久连接**

> 引入了持久连接，`TCP`第一次连接默认不关闭，可以被多个请求复用，不用声明：`Connection:keep-alive`,客户端和服务器发现对方一段时间没有活动就可以关闭连接。
>
> 规范的做法：客户端在最后一次请求时`Connection:close`,明确要求服务器关闭连接

目前对于同一个域名，大多数浏览器允许同时建立6个连接

**管道机制**

同一个`TCP`请求里，客户端可以发送多个请求

**分块传输编码**

只要请求头或响应头信息有`Transfer-Encoding`字段，表明回应由数量为定的数据块组成

> Transfer-Encoding: chunked

**其他功能**

新增了：`PUT` `PATCH` `HEAD` `OPTIONS` `DELETE`方法

请求头信息新增了`Host`字段，指定服务器的域名

**该版本缺点**

> 多条TCP连接带宽竞争

> 虽然该版本支持复用`TCP`请求，但所有的数据通信还是按次序进行的，只有服务器处理完上一个回应，才会进行下一个回应，要是前面的回应特别慢就会由许多请求排队等着,这种称为`队头堵塞`

为了避免该版本的缺点，只有两种方法：一是减少请求数，二是同时多开持久化连接，所以产生了很多网页优化技巧，比如合并脚本和样式表，将图片前途css代码、`域名分片`等

`域名分片`:把静态资源划分出多个独立的域名进行并发请求

- `HTTP/2` 2015 

**二进制传输**

HTTP/2 采用二进制格式传输数据，而非HTTP/1.1 里纯文本形式的报文 ，二进制协议解析起来更高效。

**Header压缩**

HTTP/1.1的header带有大量信息，而且每次都要重复发送，HTTP/2并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。

**多路复用**

多路复用允许同时通过单一的HTTP/2连接发起多重的请求-响应信息，很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。

**Server Push**

在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push）。

- `HTTP/3` 2018/10

### HTTP和HTTPS的区别

HTTP（Hyper Text Transfer Protocol，超文本传输协议）被用于在web浏览器和网站服务器之间传递信息，HTTP协议以`明文`的方式发送内容，不提供任何方式的数据加密，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号，密码等支付信息。

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer，安全套接字超文本传输协议），为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS，依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。其中SSL（Secure Socket Layer，安全套接层），TLS（Transport Layer Securit，传输层安全协议），SSL 3.0和TLS 1.0差别很小，在HTTPS通信中具体使用哪一个还要看客户端和服务端的支持程度，二者在网络模型中位于哪一层？

区别：

（1）HTTPS协议需要CA申请证书，一般免费证书比较少，所以需要一定费用

（2）HTTP是超文本传输协议，信息室明文传输，HTTPS则是具有安全性的SSL加密传输协议

（3）HTTP和HTTPS使用的是完全不同的连接方式，使用的端口号也不一样，前者是80，后者是443

（4）HTTP连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，比较安全。

（5）谷歌搜索引擎算法中，比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中排名会更高


### **客户端使用HTTPS方式与web服务器通信的步骤：**

（1）客户使用HTTPS的URL访问web服务器，要求与web服务器建立SSL连接

（2）web服务器收到客户端请求后，将网站的证书信息（证书中包含公钥）传送一份给客户端

（3）客户端的浏览器与web服务器开始协商SSL连接的安全等级，也就是信息的加密等级

（4）客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站

（5）web服务器利用自己的私钥解密出会话秘钥

（6）web服务器利用会话秘钥加密与客户端之间的通信

### **浏览器同源策略**

（1）浏览器安全的基石是“同源策略”（same-origin policy）。所谓“同源”指的是“三个相同”：

- 协议相同
- 域名相同
- 端口相同

（2）同源策略的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。

 （3）如果非同源，共有三种行为受到限制：

- Cookie、LocalStorage和IndexDB无法读取
- DOM无法获得
- AJAX请求不能发送

（4）不受同源策略限制的：

- 页面中的链接，重定向以及表单提交
- 跨域资源的引入是可以的，但是js不能读写加载的内容。（如<script src=...></script>，<img>，<link>，<iframe>）

### 长链接和短链接

#### 短链接

完成一次通信之后，客户端主动断开TCP连接；

`HTTP/1.0`中，默认使用的是**短连接**。也就是说，浏览器和服务器每进行一次`HTTP`操作，就建立一次连接（三次握手），结束就中断（四次挥手）；

#### 长链接

完成一次通信之后，客户端不主动断开 `TCP`连接，而是复用该`TCP`连接；

`HTTP/1.1`起，默认使用**长连接**，用以保持连接特性。此时通用首部字段中的`Connection`字段值为：`Keep-Alive`；

长连接适用于频繁地传输数据的客户端和服务器，为了防止过多的TCP连接影响服务器性能，需要对长时间不用的连接进行释放；

### 缓存工作方式（强缓存和协商缓存）

1. 场景一：

让服务器与浏览器约定一个文件过期时间————`Expires`，在`Expires`没有过期的情况下，客户端发出请求时，直接使用HTTP本地缓存并返回200，这种方式称为`强制缓存`

2. 场景二：

让服务器在与浏览器在约定文件过期时间`Expires`的基础上，再加一个文件最新修改时间的对比————`Last-Modified`与`If-Modified-Since`

- 情况1：如果`Expires`没有过期，直接采用强制缓存
- 情况2：如果`Expires`过期了，那么浏览器在请求服务器的时候，就带上了文件最新修改时间，这个字段是在请求头上面加了`Is-Modified-Since`字段，其实该字段的值就是上次请求时服务器返回的`Last-Modified`值；服务器会把请求头里的`If-Last-Modified`的值与服务器上的文件最新修改时间`Last-Modified`的值进行比较
  - 如果`If-Modified-Since` **不等于**`Last-Modified`，说明浏览器缓存的资源（`f.js`）发生改变，服务器就会去查找最新的`f.js`，同时再次返回`Expires`、`f.js`、`Last-Modified`，返回的状态码为`200`;
  - 如果`If-Modified-Since` **等于**`Last-Modified`，说明浏览器缓存的资源（`f.js`）没有发生改变，浏览器可以继续使用`HTTP`本地缓存，此时服务器返回状态码`304`；这种方式称为**协商缓存**

3. 场景三：

让服务器在过期时间`Expires`+`Last-Modified`的基础上，增加一个文件唯一标识`Etag`与`If-None-Match`配成一对使用；除此之外，`Expires`不稳定，再加入一个`Max-age`来加以替代（`Max-age`优先级更高）

- 在60s内，浏览器不再向服务器发起请求，直接使用本地缓存这与`Expires`相似。
- 60s后：浏览器带上`If-Modified-Since`和`If-None-Match`（也就是上次服务器返回的`Etag`值）发起请求，服务器会对比`If-None-Match`与服务器端的`Etag`值，这时即使浏览器也提供了`If-Modified-Since`也不会再与`Last-Modified`进行对比，因为`Etag`的优先级比`Last-Modified`高（更精准）；
  - 如果`If-None-Match`**不等于**`Etag`，说明`f.js`文件已被修改，服务器就会返回最新的`f.js`和全新的`Etag`与`Max-age`（比如`60`），当然也会顺便把`Expires`与`Last-Modified`返回（尽管没用）；返回的状态码为`200`；
  - 如果`If-None-Match`**等于**`Etag`，说明`f.js`文件没有被修改，这时服务器返回的状态码为`304`，告诉浏览器继续使用原来的本地缓存。这种方式属于**协商缓存**；

**有了Last-Modified为什么还要用Etag呢？**

你可能会觉得使用`Last-Modified`已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要`Etag`呢？`HTTP1.1`中`Etag`的出现主要是为了解决几个`Last-Modified`比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说`1s`内修改了`N`次)，`If-Modified-Since`能检查到的粒度是`s`级的，这种修改无法判断（比如淘宝每`ms`都会更新数据）；
- 某些服务器不能精确的得到文件的最后修改时间；

这时，利用`Etag`能够更加准确的控制缓存，因为`Etag`是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。 `Last-Modified`与`ETag`是可以一起使用的，服务器会优先验证`ETag`，一致的情况下，才会继续比对`Last-Modified`，最后才决定是否返回`304`。

#### 强制缓存和协商缓存区别

- 强制缓存：直接使用`http`本地缓存，此时服务器返回状态码时200
- 协商缓存：向服务器确认`http`本地缓存的资源是否发生变化，没变化后再使用`http`本地缓存，此时服务器返回状态时304；资源发生变化直接返回最新资源，状态码为200；可以这样理解凡是304状态码，都属于`协商缓存`

请求头`Cache-control`的值为no-cache时表示浏览器会向服务器确认缓存的新鲜度，再决定是否使用缓存，属于`协商缓存`

浏览器操作对缓存的影响

|   用户操作    | Expires/Cache-Control | Last-Modified/Etag |
| :-----------: | :-------------------: | :----------------: |
|  地址栏回车   |         有效          |        有效        |
| 页面链接跳转  |         有效          |        有效        |
|   新开窗口    |         有效          |        有效        |
|  前进、后退   |         有效          |        有效        |
|    F5刷新     |       **无效**        |        有效        |
| Ctrl + F5刷新 |       **无效**        |      **无效**      |

### 流程图

![](https://user-images.githubusercontent.com/25027560/38223505-d8ab53da-371d-11e8-9263-79814b6971a5.png)



### 关于http中的keep-alive	

> 在http早期，每一个http请求都要打开一个tcp socket 连接，并且使用一次后就会断开连接。使用keep-alive可以改善这种状态，减少tcp请求次数，减少TIME_WAIT状态连接，以此提高性能和httpd服务器的吞吐率，但是keep-alive并不代表可以永久使用，长时间容易导致系统资源无效占用，比重复利用连接带来的损失还要大，所以要正确设置keep-alive的时间。

